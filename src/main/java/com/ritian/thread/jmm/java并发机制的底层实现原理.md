#### 1.volatile的应用
>定义：保证了共享变量的“可见性”。可见性的意思是指当一个线程修改这个共享变量时，另外一个线程能读到这个修改的值。
<br>原理：
通过查看字节码，使用volatile修饰的共享变量进行写操作时会多出一个lock汇编代码。在单核CPU下，是不存在可见性的问题的。多核CPU下
**volatile的两条实现原则**
<br>1.Lock前缀指令会引起处理器缓存回写到内存
<br>2.一个处理器的缓存回写到内存会导致其它处理器的缓存无效（缓存一致性）
<br>参考[《volatile关键字是如何保证可见性的》](http://www.tianshouzhi.com/api/tutorials/mutithread/286)
#### 2.synchronized的实现原理与应用
>Java SE 1.6之前一直是重量级锁，1.6对其进行了各种优化，为了减少获得锁和释放锁带来性能的消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程，有些情况下它就不是那么重了。
<br>**synchronized实现同步主要表现为以下3种形式**
<br>1.对于普通同步方法，锁是当前实例对象
<br>2.对于静态同步方法，锁是当前类的Class对象
<br>3.对于同步方法快，锁是synchronized括号里配置的对象。
<br>**原理**
<br>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，使用monitorenter和monitorexit指令实现的。
#### 3.原子操作的实现原理
>**处理器如何实现原子操作**
<br>1.使用总线锁保证原子性
<br>2.使用缓存锁保证原子性
<br>**java中如何实现原子操作**
<br>可以通过锁和循环CAS的方式来实现原子操作
<br>**CAS实现原子操作的三大问题**
<br>1.ABA问题
<br>2.循环时间长开销大
<br>3.只能保证一个共享变量的原子操作